Каждый DOM-узел принадлежит соответствующему встроенному классу.

Корнем иерархии является EventTarget, от него наследует Node и остальные DOM-узлы.

Основные классы:

![[Pasted image 20240908180718.png]]

Существуют следующие классы:

- EventTarget – это корневой «абстрактный» класс для всего.
    
    Объекты этого класса никогда не создаются. Он служит основой, благодаря которой все DOM-узлы поддерживают так называемые «события», о которых мы поговорим позже.
    
- Node – также является «абстрактным» классом, и служит основой для DOM-узлов.
    
    Он обеспечивает базовую функциональность: `parentNode`, `nextSibling`, `childNodes` и т.д. (это геттеры). Объекты класса `Node` никогда не создаются. Но есть определённые классы узлов, которые наследуются от него (и следовательно наследуют функционал `Node`).
    
- Document, по историческим причинам часто наследуется `HTMLDocument` (хотя последняя спецификация этого не навязывает) – это документ в целом.
    
    **Глобальный объект `document` принадлежит именно к этому классу. Он служит точкой входа в DOM.**
    
- CharacterData – «абстрактный» класс. Вот, кем он наследуется:
    
    - Text – класс, соответствующий тексту внутри элементов. Например, `Hello` в `<p>Hello</p>`.
    - Comment – класс для комментариев. Они не отображаются, но каждый комментарий становится членом DOM.
- Element – это базовый класс для DOM-элементов.
    
    Он обеспечивает навигацию на уровне элементов: `nextElementSibling`, `children`. А также и методы поиска элементов: `getElementsByTagName`, `querySelector`.
    
    Браузер поддерживает не только HTML, но также XML и SVG. Таким образом, класс `Element` служит основой для более специфичных классов: `SVGElement`, `XmlElement` (они нам здесь не нужны) и `HTMLElement`.
    
- И наконец, HTMLElement является базовым классом для всех остальных HTML-элементов. Мы будем работать с ним большую часть времени.
    
    От него наследуются конкретные элементы:
    
    - HTMLInputElement – класс для тега `<input>`,
    - HTMLBodyElement – класс для тега `<body>`,
    - HTMLAnchorElement – класс для тега `<a>`,
    - …и т.д.

# Пример

Рассмотрим DOM-объект для тега `<input>`. Он принадлежит классу HTMLInputElement.

Он получает свойства и методы из (в порядке наследования):

- `HTMLInputElement` – этот класс предоставляет специфичные для элементов формы свойства,
- `HTMLElement` – предоставляет общие для HTML-элементов методы (и геттеры/сеттеры),
- `Element` – предоставляет типовые методы элемента,
- `Node` – предоставляет общие свойства DOM-узлов,
- `EventTarget` – обеспечивает поддержку событий (поговорим о них дальше),
- …и, наконец, он наследует от `Object`, поэтому доступны также методы «обычного объекта», такие как `hasOwnProperty`.Для того, чтобы узнать имя класса DOM-узла, вспомним, что обычно у объекта есть свойство `constructor`. Оно ссылается на конструктор класса, и в свойстве `constructor.name` содержится его имя

# Главные свойства DOM-узла

**`nodeType`**

Свойство `nodeType` позволяет узнать тип DOM-узла. Его значение – числовое: `1` для элементов,`3` для текстовых узлов, и т.д. Только для чтения.

**`nodeName/tagName`**

Для элементов это свойство возвращает название тега (записывается в верхнем регистре, за исключением XML-режима). Для узлов-неэлементов `nodeName` описывает, что это за узел. Только для чтения.

**`innerHTML`**

Внутреннее HTML-содержимое узла-элемента. Можно изменять.

**`outerHTML`**

Полный HTML узла-элемента. Запись в `elem.outerHTML` не меняет `elem`. Вместо этого она заменяет его во внешнем контексте.

**`nodeValue/data`**

Содержимое узла-неэлемента (текст, комментарий). Эти свойства практически одинаковые, обычно мы используем `data`. Можно изменять.

**`textContent`**

Текст внутри элемента: HTML за вычетом всех `<тегов>`. Запись в него помещает текст в элемент, при этом все специальные символы и теги интерпретируются как текст. Можно использовать для защиты от вставки произвольного HTML кода.

**`hidden`**

Когда значение установлено в `true`, делает то же самое, что и CSS `display:none`.

# Создание DOM элемента

DOM-узел можно создать двумя методами:

**`document.createElement(tag)`**

Создаёт новый _элемент_ с заданным тегом:

```jsx
let div = document.createElement('div');
```

**`document.createTextNode(text)`**

Создаёт новый _текстовый узел_ с заданным текстом:

```jsx
let textNode = document.createTextNode('А вот и я');
```

# Методы вставки

Чтобы наш `div` появился, нам нужно вставить его где-нибудь в `document`. Например, в `document.body`.

Для этого есть метод `append`, в нашем случае: `document.body.append(div)`.

Вот полный пример:

```jsx
<style>
.alert {
  padding: 15px;
  border: 1px solid #d6e9c6;
  border-radius: 4px;
  color: #3c763d;
  background-color: #dff0d8;
}
</style>

<script>
  let div = document.createElement('div');
  div.className = "alert";
  div.innerHTML = "<strong>Всем привет!</strong> Вы прочитали важное сообщение.";

  document.body.append(div);
</script>
```

Вот методы для различных вариантов вставки:

- `node.append(...nodes or strings)` – добавляет узлы или строки в конец `node`,
- `node.prepend(...nodes or strings)` – вставляет узлы или строки в начало `node`,
- `node.before(...nodes or strings)` –- вставляет узлы или строки до `node`,
- `node.after(...nodes or strings)` –- вставляет узлы или строки после `node`,
- `node.replaceWith(...nodes or strings)` –- заменяет `node` заданными узлами или строками.

# Удаление узлов

Для удаления узла есть методы `node.remove()`.

Например, сделаем так, чтобы наше сообщение удалялось через секунду:

```jsx
<style>
.alert {
  padding: 15px;
  border: 1px solid #d6e9c6;
  border-radius: 4px;
  color: #3c763d;
  background-color: #dff0d8;
}
</style>

<script>
  let div = document.createElement('div');
  div.className = "alert";
  div.innerHTML = "<strong>Всем привет!</strong> Вы прочитали важное сообщение.";

  document.body.append(div);
  setTimeout(() => div.remove(), 1000);
</script>
```

# Перемещение узлов

Если нам нужно _переместить_ элемент в другое место – нет необходимости удалять его со старого.

**Все методы вставки автоматически удаляют узлы со старых мест.**

Например, давайте поменяем местами элементы:

```jsx
<div id="first">Первый</div>
<div id="second">Второй</div>
<script>
  // нет необходимости вызывать метод remove
  second.after(first); // берёт #second и после него вставляет #first
</script>
```