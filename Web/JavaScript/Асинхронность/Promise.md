## Синтаксис создания
```JS
let promise = new Promise(function(resolve, reject) {
	// функция (executor)
});
```
Функция, переданная в конструкцию `new Promise`, называется _исполнитель_ (executor). Когда `Promise` создаётся, **она запускается автоматически.** Она должна содержать «создающий» код, который когда-нибудь создаст результат.

Когда он получает результат, сейчас или позже – не важно, он должен вызвать один из этих колбэков:

- `resolve(value)` — если работа завершилась успешно, с результатом `value`.
- `reject(error)` — если произошла ошибка, `error` – объект ошибки.
## Что под капотом

У объекта `promise`, возвращаемого конструктором `new Promise`, есть внутренние свойства:

- `state` («состояние») — вначале `"pending"` («ожидание»), потом меняется на `"fulfilled"` («выполнено успешно») при вызове `resolve` или на `"rejected"` («выполнено с ошибкой») при вызове `reject`.
- `result` («результат») — вначале `undefined`, далее изменяется на `value` при вызове `resolve(value)` или на `error` при вызове `reject(error)`.

**Важно, что эти свойства внутренние и мы не имеем к ним прямого доступа!**

Исполнитель должен вызвать что-то одно: `resolve` или `reject`. Состояние промиса может быть изменено только один раз.

Все последующие вызовы `resolve` и `reject` будут проигнорированы:
```JS
let promise = new Promise(function(resolve, reject) {
	resolve('done');

	reject(new Error('...')); // Игнорируется
	setTimeout(() => resolve('done')) // Игнорируется
})
```

Также заметим, что функция `resolve/reject` __ожидает только один аргумент (или ни одного).__ Все дополнительные аргументы будут проигнорированы.
## Error как аргумент reject

В случае, если что-то пошло не так, мы должны вызвать `reject`. Это можно сделать с аргументом любого типа (как и `resolve`), но **рекомендуется использовать объект `Error`.**