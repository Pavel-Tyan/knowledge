## Mетод `then`
```js
promise.then(
	function(result) {/* выполняется при успешном выполнении */},
	function(error) {/* выполняется при ошибке */}
);
```
Первый аргумент метода `.then` – функция, которая выполняется, когда промис переходит в состояние «выполнен успешно», и получает результат. **(Для этого мы передаем в resolve аргумент)**

Второй аргумент `.then` – функция, которая выполняется, когда промис переходит в состояние «выполнен с ошибкой», и получает ошибку. **(Для этого мы передаем в reject аргумент)**

```JS
let promise = new Promise(function(resolve, reject) {
	resolve('done');
});

promise.then(
	result => console.log(result), // выведет 'done'
	error => console.log(error) // не будет запущена
);
```

```JS
let promise = new Promise(function(resolve, reject) {
	reject(new Error('Oh'));
});

promise.then(
	result => console.log(result), // не будет запущена
	error => console.log(error) // выведет Error: Oh
);
```
__“done” из resolve передался как result в then().__

Можно передать в then только 1 функцию, если нас не интересует reject
```JS
let promise = new Promise(function(resolve, reject) {
	resolve('done')
});

promise.then(
	result => console.log(result), // выведет 'done'
);

```
## Mетод `catch`
Если мы хотели бы только обработать ошибку
```JS
let promise = new Promise(function(resolve, reject) {
	reject(new Error('Oh'));
});

promise.catch(
	error => console.log(error), // выведет Error: Oh
);
```

Вызов `.catch(f)` – это сокращённый, «укороченный» вариант `.then(null, f).`
## Метод finally
По аналогии с блоком `finally` из обычного `try {...} catch {...}`, у промисов также есть метод `finally`.

Вызов `.finally(f)` похож на `.then(f, f)`, в том смысле, что `f` выполнится в любом случае, когда промис завершится: успешно или с ошибкой.

Идея `finally` состоит в том, чтобы настроить обработчик для выполнения очистки/доведения после завершения предыдущих операций.

```JS
new Promise((resolve, reject) => {
	//...
	resolve(1);
})

	.finally(() => {/*...*/})
	.then((res) => {/*...*/})
```
Есть важные различия:

1. Обработчик, вызываемый из `finally`, не имеет аргументов. В `finally` мы не знаем, как был завершён промис.
   
2. Результат promise обрабатывается в следующем обработчике.
    
3. Обработчик `finally` «пропускает» результат или ошибку дальше, к последующим обработчикам.
## Цепочки промисов
```JS
new Promise(function(resolve, reject) {
	resolve(1);
}).then(result => {
	console.log(result);
	return result * 2;
}).then(result => {
	console.log(result);
	return result * 2;
})
```
Идея состоит в том, что результат первого промиса передаётся по цепочке обработчиков `.then`.

Поток выполнения такой:

1. Начальный промис успешно выполняется через 1 секунду `(*)`,
2. Затем вызывается обработчик в `.then` `(**)`.
3. Возвращаемое им значение передаётся дальше в следующий обработчик `.then` `(***)`
4. …и так далее.

В итоге результат передаётся по цепочке обработчиков, и мы видим несколько `alert` подряд, которые выводят: `1` → `2` → `4`.

Всё это работает, потому что вызов `promise.then` **тоже возвращает промис**, так что мы можем вызвать на нём следующий `.then`.

## return new Promise(…)
Обработчик `handler`, переданный в `.then(handler)`, может вернуть промис.

В этом случае дальнейшие обработчики __ожидают, пока он выполнится,__ и затем получают его результат.

```JS
new Promise(function(resolve, reject) {
	resolve(1);
}).then(result => {
	console.log(result);
	return new Promise((resolve, reject) => {
		setTimeout(() => resolve(result * 2), 1000);
	})
}).then(result => {
	console.log(result);
	return new Promise((resolve, reject) => {
		setTimeout(() => resolve(result * 2), 1000);
	})
})

```
## Обработка ошибок
**Цепочки промисов отлично подходят для перехвата ошибок. Если промис завершается с ошибкой, то управление переходит в ближайший обработчик ошибок.** На практике это очень удобно.

Например, в представленном ниже примере для `fetch` указана неправильная ссылка (сайт не существует), и `.catch` перехватывает ошибку:
```JS
fetch('...')
	.then(response => response.json())
	.catch(err => console.log(err)) // Здесь ловится ошибка 
```
Как видно, .catch не обязательно должен быть сразу после ошибки, он может быть далее, после одного или даже нескольких `.then`. 

__Бывает удобным добавлять `catch` в конец длинной цепочки промисов, чтобы ловить ошибки.__

## Неявный `try...catch`
Вокруг функции промиса и обработчиков находится "невидимый try..catch". Если происходит исключение, то оно перехватывается, и промис считается отклонённым с этой ошибкой.

```JS
new Promise((resolve, reject) => {
	// Можно было написать reject(new Error('Oh'));
	throw new Error('Oh');
}).catch(console.log); // Error: Oh
```

"Невидимый `try..catch`" вокруг промиса автоматически перехватывает ошибку и превращает её в отклонённый промис.

Это работает не только в функции промиса, но и в обработчиках. Если мы бросим ошибку (`throw`) из обработчика (`.then`), то промис будет считаться отклонённым, и управление перейдёт к ближайшему обработчику ошибок.

Это происходит для всех ошибок, не только для тех, которые вызваны оператором throw. Например, программная ошибка:
```JS
new Promise((resolve, reject) => {
	blabla(); // нет такой функции
}).catch(console.log); // Error
```
Финальный .catch перехватывает как промисы, в которых вызван reject, так и случайные ошибки в обработчиках.

## Проброс ошибок
В обычном `try..catch` мы можем проанализировать ошибку и повторно пробросить дальше, если не можем её обработать. То же самое возможно для промисов.

Если мы пробросим (`throw`) ошибку внутри блока `.catch`, то управление перейдёт к следующему ближайшему обработчику ошибок. А если мы обработаем ошибку и завершим работу обработчика нормально, то продолжит работу ближайший успешный обработчик `.then`.

```JS
new Promise((resolve, reject) => {
	blabla(); // нет такой функции
}).catch(error => {
	console.log('Ошибка обработана.');
}).then(() => console.log('Ошибка обработана. Идем дальше'))
```
Здесь блок .catch завершается нормально (не выбрасывает ошибку). Поэтому вызывается следующий успешный обработчик `.then`.