Массив – это особый подвид объектов. Квадратные скобки, используемые для того, чтобы получить доступ к свойству `arr[0]` – это по сути обычный синтаксис доступа по ключу, как `obj[key]`, где в роли `obj` у нас `arr`, а в качестве ключа – числовой индекс.
## Объявление
```JS
let arr = new Array();
let arr = [];

// В скобках мы можем указать начальные значения элементов:
let numbers = [1, 2, 3];
```

Общее число элементов массива содержится в его свойстве `length`:
```JS
let numbers = [1, 2, 3];
alert(numbers.length) // 3
```

Вывести весь массив можно без `for`:
```JS
let numbers = [1, 2, 3];
alert(numbers) // 1, 2, 3
```

В массиве могут храниться элементы любого типа.
```JS
let arr = [1, 'str', true, {age: 30}, function() { alert('Привет') }]
```

## Обращение к элементу
Помимо обращения через квадратные скобки можно использовать `at()`, чтобы удобнее брать элементы с конца
```JS
let numbers = [1, 2, 3];
alert(numbers.at(-1)) // 3
```

## Методы массива
**Методы, работающие с концом массива:**

`pop`
Удаляет последний элемент из массива и возвращает его.

`push`
Добавляет элемент в конец массива.

`shift`
Удаляет из массива первый элемент и возвращает его.

`unshift`
Добавляет элемент в начало массива.

Методы `push` и `unshift` могут добавлять сразу несколько элементов:
```JS
let numbers = [3, 4];

numbers.push(5, 6);
numbers.unshift(1, 2);

// [1, 2, 3, 4, 5, 6];
```

## Копирование
Т.к. массив это объект, то он копируется по ссылке. 
Удобный способ копирование массива через spread оператор (если в массиве нет объектов, иначе нужно "глубокое" копирование):
```JS
const arr = [1, 2];
const copy = [...arr];

copy.push(3);
// Разные массивы
console.log(arr); // 1, 2, 3
console.log(copy); // 1, 2, 3, 4
```

## Особенность массивов
…Но то, что действительно делает массивы особенными – это их внутреннее представление. Движок JavaScript старается хранить элементы массива в непрерывной области памяти, один за другим, так, как это показано на иллюстрациях к этой главе. Существуют и другие способы оптимизации, благодаря которым массивы работают очень быстро.

## for in vs for of
Для перебора элементов следует использовать `for...of`:
```JS
for (let num of numbers) {
 ...
}
```
Разница с `for...in`: 
1. Цикл `for..in` выполняет перебор _всех свойств_ объекта, а не только цифровых.
    
    В браузере и других программных средах также существуют так называемые «псевдомассивы» – объекты, которые _выглядят, как массив_. То есть, у них есть свойство `length` и индексы, но они также могут иметь дополнительные нечисловые свойства и методы, которые нам обычно не нужны. Тем не менее, цикл `for..in` выведет и их. Поэтому, если нам приходится иметь дело с объектами, похожими на массив, такие «лишние» свойства могут стать проблемой.
    
2. Цикл `for..in` оптимизирован под произвольные объекты, не массивы, и поэтому в 10-100 раз медленнее. Увеличение скорости выполнения может иметь значение только при возникновении узких мест. Но мы всё же должны представлять разницу.

## length и очистка
Свойство `length` автоматически обновляется при изменении массива. Если быть точными, это не количество элементов массива, а наибольший цифровой индекс плюс один.

Например, единственный элемент, имеющий большой индекс, даёт большую длину:
```js
let numbers = [];
numbers[123] = '123';
alert(numbers.length) // 124
```

Ещё один интересный факт о свойстве `length` – его можно перезаписать.

Если мы вручную увеличим его, ничего интересного не произойдёт. Зато, если мы уменьшим его, массив станет короче. Этот процесс необратим, как мы можем понять из примера:

```JS
let arr = [1, 2, 3, 4, 5];

arr.length = 2; // укорачиваем
alert(arr); // [1, 2]

arr.lenght = 5;
alert(arr[3]) // undefined
```
Таким образом, самый простой способ очистить массив – это `arr.length = 0;`.

## Синтаксис для многомерных массивов
```JS
Array(9).fill().map(()=>Array(9).fill())
```

## Еще методы
### Метод `arr`.`splice(start, [deleteCount, elem1, ..., elemN])`

Он изменяет `arr` начиная с индекса `start`: удаляет `deleteCount` элементов и затем вставляет `elem1, ..., elemN` на их место. Возвращает массив из удалённых элементов.

```JS
let arr = [1, 2, 3]
	arr.splice(1, 1); // Начиная с индекса 1 удалить 1 элемент
alert(arr) // [1, 3]
```

Отрицательные индексы разрешены:
```JS
let arr = [1, 2, 5];
// начиная с индекса -1
// удалить 0 элементов
// затем вставить 3 и 4
arr.splice(-1, 0, 3, 4);
alert(arr); // 1, 2, 3, 4, 5
```

### Метод `arr.slice([start], [end])`

Он возвращает новый массив, в который копирует все элементы с индекса `start` до `end` (не включая `end`). `start` и `end` могут быть отрицательными, в этом случае отсчёт позиции будет вестись с конца массива.

```JS
let arr = [1, 2, 3, 4];

alert(arr.slice(1, 3)); // 2, 3 (копирует с 1 до 3)
alert(arr.slice(-2)); // 3, 4 (копирует с -2 до конца)
```

### Метод `arr.concat(arg1, arg2...)` 

__Cоздаёт новый массив__, в который копирует данные из других массивов и дополнительные значения.

Он принимает любое количество аргументов, которые могут быть как массивами, так и простыми значениями.

В результате – новый массив, включающий в себя элементы из `arr`, затем `arg1`, `arg2` и так далее.

Если аргумент `argN` – массив, то копируются все его элементы. Иначе копируется сам аргумент.

```JS
let arr = [1, 2];

alert(arr.concat([3, 4])); // 1, 2, 3, 4

alert(arr.concat([3, 4], [5, 6])); // 1, 2, 3, 4, 5, 6

alert(arr.concat([3, 4], 5, 6)); // 1, 2, 3, 4, 5, 6
```

## Методы для перебора
### Метод `arr.forEach` 
Позволяет запускать функцию для каждого элемента массива.

Синтаксис:
```JS
arr.forEach(function(item, index, array) {
	// ...
})
```

`indexOf/lastIndexOf и includes` работает аналогично строковым аналогам:
- `arr.indexOf(item, from)` ищет `item` начиная с индекса `from` и возвращает номер индекса, на котором был найден искомый элемент, в противном случае `-1`.
- `arr.includes(item, from)` ищет `item` начиная с индекса `from` и возвращает `true`, если поиск успешен.
```JS
const arr = [1, 2];

arr.forEach((item) => {
	console.log(item) // 1, 2
})
```
### Метод `arr.find, arr.findIndex, arr.findLastIndex`
Синтаксис:
```JS
let res = arr.find(function(item, index, array)) {
	// если true => возвращаем текущий элемент
	// не нашли элемент => возвращаем undefined  
}
```
Функция вызывается по очереди для каждого элемента массива:
- `item` – очередной элемент.
- `index` – его индекс.
- `array` – сам массив.

Если функция возвращает `true`, поиск прерывается и возвращается `item`. Если ничего не найдено, возвращается `undefined`.

```JS
const arr = [1, 2];

let res = arr.find(item => item === 1) // 1
```

`arr.findIndex` работает также, только возвращает индекс. 
`arr.findLastIndex` работае также, но проходится по массиву с конца. 
### Метод `arr.filter`
Возвращает __новый массив__ из всех подходящих элементов:
```JS
let res = arr.filter(function(item, index, array)) {
	// ...
}
```

```JS
const arr = [1, 2, 3, 4];
const res = arr.filter(item => item > 3)

console.log(arr) // 1, 2, 3, 4
console.log(res) // 4
```

## Методы преобразования массива
### Метод `arr.map` 
Он вызывает функцию для каждого элемента массива и возвращает __новый массив__ результатов выполнения этой функции.
```JS
let res = arr.map(function(item, index, array)) {
	// ...
}
```

```JS
const arr = [1, 2, 3, 4];
const res = arr.map(item => item + 1);

console.log(arr); // 1, 2, 3, 4
console.log(res); // 2, 3, 4, 5
```
### Метод `arr.sort(fn)`
Сортирует массив __на месте__, меняя в нём порядок элементов.

Он также возвращает отсортированный массив, но обычно возвращаемое значение игнорируется, так как изменяется сам `arr`.

__По умолчанию сортирует элементы как строки!__

```JS
// По умолчанию
const arr = [1, 3, 13];
arr.sort();

console.log(arr) // 1, 13, 3

// Исправим
const arr = [1, 3, 13];
arr.sort((a, b) => a - b);

console.log(arr) // 1, 3, 13

// Если а > b, то должно возвращаться любое положительное число, 
// если a <  b, то отрицательное.
```

### Метод `arr.reverse`
Меняет порядок элементов __на месте__

### Метод `arr.reduce`
```JS
let value = arr.reduce(function(accumulator, item, index, array) {
	 // ...
}, [initial])
```

Функция применяется по очереди ко всем элементам массива и «переносит» свой результат (__нужно использовать return__ в callback) на следующий вызов.

Аргументы:
- `accumulator` – результат предыдущего вызова этой функции, равен `initial` при первом вызове (если передан `initial`),
- `item` – очередной элемент массива,
- `index` – его позиция,
- `array` – сам массив.
```JS
let arr = [1, 2, 3, 4, 5]

let res = arr.reduce((sum, item) => sum + current, 0)

console.log(res) // 15
```

## Метод Array.isArray
Массивы не образуют отдельный тип данных. Они основаны на объектах.
Поэтому `typeof` не может отличить простой объект от массива:
```JS
alert(typeof {}) // object
alert(typeof []) // object
```
…Но массивы используются настолько часто, что для этого придумали специальный метод: Array.isArray(value). Он возвращает `true`, если `value` массив, и `false`, если нет.
```JS
alert(Array.isArray({})) // false;
alert(Array.isArray([])) // true;
```

## thisArg
Почти все методы массива, которые вызывают функции – такие как `find`, `filter`, `map`, за исключением метода `sort`, принимают необязательный параметр `thisArg`.

Этот параметр не объяснялся выше, так как очень редко используется, но для наиболее полного понимания темы мы обязаны его рассмотреть.

Вот полный синтаксис этих методов:
```JS
arr.find(func, thisArg);
arr.filter(func, thisArg);
arr.map(func, thisArg);
// ...
```

Значение параметра `thisArg` становится `this` для `func`.

Например, тут мы используем метод объекта `army` как фильтр, и `thisArg` передаёт ему контекст:
```JS
let army = { 
	minAge: 18, 
	maxAge: 27, 
	canJoin(user) { 
		return user.age >= this.minAge && user.age < this.maxAge; 
	} 
}; 

let users = [ {age: 16}, {age: 20}, {age: 23}, {age: 30} ]; 
// найти пользователей, для которых army.canJoin возвращает true 
let soldiers = users.filter(army.canJoin, army); 
alert(soldiers.length); // 2 
alert(soldiers[0].age); // 20 
alert(soldiers[1].age); // 23
```

Если бы мы в примере выше использовали просто `users.filter(army.canJoin)`, то вызов `army.canJoin` был бы в режиме отдельной функции, с `this=undefined`. Это тут же привело бы к ошибке.

Вызов `users.filter(army.canJoin, army)` можно заменить на `users.filter(user => army.canJoin(user))`, который делает то же самое. Последняя запись используется даже чаще, так как функция-стрелка более наглядна.


