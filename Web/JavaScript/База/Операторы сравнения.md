## Сравнение строк
Алгоритм сравнения двух строк довольно прост:
```JS
alert('Я' > 'А'); // true
alert('Коты' > 'Кода'); // true 
alert('Сонный' > 'Сон'); // true
```

1. Сначала сравниваются первые символы строк.
2. Если первый символ первой строки (код Unicode) больше (меньше), чем первый символ второй, то первая строка больше (меньше) второй. Сравнение завершено. __Используется кодировка Unicode, а не настоящий алфавит__
3. Если первые символы равны, то таким же образом сравниваются уже вторые символы строк.
4. Сравнение продолжается, пока не закончится одна из строк.
5. Если обе строки заканчиваются одновременно, то они равны. Иначе, большей считается более длинная строка.

__Для многих алфавитов лучше использовать метод `str.localeCompare`, для правильной сортировки букв, таких как `Ö`.__
## Сравнение разных типов
При сравнении значений разных типов JavaScript приводит каждое из них к числу.
```JS
alert('2' > 1);   // true, строка '2' становится числом 2 
alert('01' == 1); // true, строка '01' становится числом 1
```
Логическое значение `true` становится `1`, а `false` – `0`.
```JS
alert(true == 1);  // true
alert(false == 0); // true`
```
## Строгое сравнение
**Оператор строгого равенства `===` проверяет равенство без приведения типов.**
```JS
alert(0 == false); // true, из-за приведения типов
alert(0 === false); // false, так как сравниваются разные типы

alert(null == undefined); // true
alert(null === undefined); // false
```
Странный пример:
```JS
alert(null > 0); // (1) false 
alert(null == 0); // (2) false
alert(null >= 0); // (3) true
```
Причина в том, что нестрогое равенство и сравнения `> < >= <=` работают по-разному. Нестрогие сравнения преобразуют `null` в число, 
рассматривая его как `0`. Поэтому выражение (3) `null >= 0` истинно, а `null > 0` ложно.

С другой стороны, для нестрогого равенства `==` значений `undefined` и `null` действует особое правило: эти значения ни к чему не приводятся, они равны друг другу и не равны ничему другому. Поэтому (2) `null == 0` ложно.
## undefined
```JS
alert(undefined > 0); // (1) false 
alert(undefined < 0); // (2) false
alert(undefined == 0); // (3) false

alert(undefined == null) // true;
```
Почему же сравнение `undefined` с нулём всегда ложно?

На это есть следующие причины:

- Сравнения `(1)` и `(2)` возвращают `false`, потому что `undefined` преобразуется в `NaN`, а `NaN` – это специальное числовое значение, которое возвращает `false` при любых сравнениях.
- Нестрогое равенство `(3)` возвращает `false`, потому что `undefined` равно только `null`, `undefined` и ничему больше.

[[Типы данных]]