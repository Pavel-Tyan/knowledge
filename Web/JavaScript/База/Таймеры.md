## setTimeout
```JS
let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...);
```
Параметры:

`func|code`
Функция или строка кода для выполнения. Обычно это функция. По историческим причинам можно передать и строку кода, но это не рекомендуется.

`delay`
Задержка перед запуском в миллисекундах (1000 мс = 1 с). Значение по умолчанию – 0.

`arg1`, `arg2`…
Аргументы, передаваемые в функцию

```JS
function sayHi() {
  alert('Привет');
} 

setTimeout(sayHi, 1000);
```

```JS
function sayHi(phrase, who) {
  alert( phrase + ', ' + who );
} 

setTimeout(sayHi, 1000, "Привет", "Джон"); // Привет, Джон
```
Вызов `setTimeout` возвращает «идентификатор таймера» `timerId`, который можно использовать для отмены дальнейшего выполнения.

Синтаксис для отмены:
```JS
let timerId = setTimeout(...);
clearTimeout(timerId);
```
В коде ниже планируем вызов функции и затем отменяем его (просто передумали). В результате ничего не происходит:

```JS
let timerId = setTimeout(() => alert("ничего не происходит"), 1000);
alert(timerId); // идентификатор таймера

clearTimeout(timerId);
alert(timerId); // тот же идентификатор (не принимает значение null после отмены)
```

Как мы видим из вывода `alert`, в браузере идентификатором таймера является число. __В других средах это может быть что-то ещё.__ Например, Node.js возвращает объект таймера с дополнительными методами.

Повторюсь, что нет единой спецификации на эти методы, поэтому такое поведение является нормальным.

## setInterval
```JS
let timerId = setInterval(func|code, [delay], [arg1], [arg2], ...);
```

Все аргументы имеют такое же значение. Но отличие этого метода от `setTimeout` в том, что функция запускается не один раз, а периодически через указанный интервал времени.

__Чтобы остановить дальнейшее выполнение функции, необходимо вызвать `clearInterval(timerId)`.__

Следующий пример выводит сообщение каждые 2 секунды. Через 5 секунд вывод прекращается:
```JS
// повторить с интервалом 2 секунды
let timerId = setInterval(() => alert('tick'), 2000);

// остановить вывод через 5 секунд
setTimeout(() => { clearInterval(timerId); alert('stop'); }, 5000);
```

## Вложенный setTimeout
Есть два способа запускать что-то регулярно.

Один из них `setInterval`. Другим является вложенный `setTimeout`.
```JS
/** вместо:
let timerId = setInterval(() => alert('tick'), 2000);
*/

let timerId = setTimeout(function tick() {
  alert('tick');
  timerId = setTimeout(tick, 2000); // (*)
}, 2000);
```

Метод `setTimeout` выше планирует следующий вызов прямо после окончания текущего `(*)`.

__Вложенный `setTimeout` – более гибкий метод, чем `setInterval`. С его помощью последующий вызов может быть задан по-разному в зависимости от результатов предыдущего.__

**Реальная задержка между вызовами `func` с помощью `setInterval` меньше, чем указано в коде!**

Это нормально, потому что время, затраченное на выполнение `func`, использует часть заданного интервала времени.

Вполне возможно, что выполнение `func` будет дольше, чем мы ожидали, и займёт более 100 мс.

В данном случае движок ждёт окончания выполнения `func` и затем проверяет планировщик и, если время истекло, _немедленно_ запускает его снова.

В крайнем случае, если функция всегда выполняется дольше, чем задержка `delay`, то вызовы будут выполняться без задержек вообще.