## Ошибки в рантайме
`try..catch` работает только для ошибок, возникающих во время выполнения кода

Чтобы `try..catch` работал, код должен быть выполнимым. Другими словами, это должен быть корректный JavaScript-код.

Он не сработает, если код синтаксически неверен, например, содержит несовпадающее количество фигурных скобок:

```JS
try {
 {{{{{{{{{{
} catch (e) {
	alert(...)
}
```

JavaScript-движок сначала читает код, а затем исполняет его. Ошибки, которые возникают во время фазы чтения, называются ошибками парсинга. Их нельзя обработать (изнутри этого кода), потому что движок не понимает код.

Таким образом, `try..catch` может обрабатывать только ошибки, которые возникают в корректном коде. Такие ошибки называют «ошибками во время выполнения», а иногда «исключениями».

## Синхронная работа
`try..catch` работает синхронно

Исключение, которое произойдёт в коде, запланированном «на будущее», например в `setTimeout`, `try..catch` не поймает:
```JS
try {
	setTimeout(function() {
		noSuchVariable; // скрипт упадет тут
	}, 1000)
} catch (e) {
	alert(...)
}
```

Это потому, что функция выполняется позже, когда движок уже покинул конструкцию `try..catch`.

Чтобы поймать исключение внутри запланированной функции, `try..catch` должен находиться внутри самой этой функции:

```JS
setTimeout(function() {
	try {
		noSuchVariable; // теперь ошибка отловится
	} catch (e) {
		alert(...)
	}
})
```

## Объект ошибки
Когда возникает ошибка, JavaScript генерирует объект, содержащий её детали. Затем этот объект передаётся как аргумент в блок `catch`:
```JS
try {
	...
} catch (err) { // объект ошибки

}
```

Для всех встроенных ошибок этот объект имеет два основных свойства:

`name`

Имя ошибки. Например, для неопределённой переменной это `"ReferenceError"`.

`message`

Текстовое сообщение о деталях ошибки.

В большинстве окружений доступны и другие, нестандартные свойства. Одно из самых широко используемых и поддерживаемых – это:

`stack`

Текущий стек вызова: строка, содержащая информацию о последовательности вложенных вызовов, которые привели к ошибке. Используется в целях отладки.

```JS
try {
  lalala; // ошибка, переменная не определена!
} catch(err) {
  alert(err.name); // ReferenceError
  alert(err.message); // lalala is not defined
  alert(err.stack); // ReferenceError: lalala is not defined at (...стек вызовов)
  // Можем также просто вывести ошибку целиком
  // Ошибка приводится к строке вида "name: message"
  alert(err); // ReferenceError: lalala is not defined
}
```

Если нам не нужны детали ошибки, в `catch` можно её пропустить:
```JS
try {

} catch {

}
```

## Проброс исключения
Техника «проброс исключения» выглядит так:

1. Блок `catch` получает все ошибки.
2. В блоке `catch(err) {...}` мы анализируем объект ошибки `err`.
3. Если мы не знаем как её обработать, тогда делаем `throw err`.

В коде ниже мы используем проброс исключения, `catch` обрабатывает только `SyntaxError`:

```JS
let json = '{ "age": 30 }'; // данные неполны

try {
  let user = JSON.parse(json);

  if (!user.name) {
    throw new SyntaxError("Данные неполны: нет имени");
  }
  
  blabla(); // неожиданная ошибка
  alert( user.name );
} catch(e) {
  if (e.name == "SyntaxError") {
    alert( "JSON Error: " + e.message );
  } else {
    throw e; // проброс (*)
  }
}
```

Ошибка в строке `(*)` из блока `catch` «выпадает наружу» и может быть поймана другой внешней конструкцией `try..catch` (если есть), или «убьёт» скрипт.

Таким образом, блок `catch` фактически обрабатывает только те ошибки, с которыми он знает, как справляться, и пропускает остальные.

## Важность finally
Блок `finally` срабатывает при _любом_ выходе из `try..catch`, в том числе и `return`.

В примере ниже из `try` происходит `return`, но `finally` получает управление до того, как контроль возвращается во внешний код.

```JS
function func() {
  try {
    return 1;
  } catch (e) {
    /* ... */
  } finally {
    alert( 'finally' );
  }
}

alert( func() ); // сначала срабатывает alert из finally, а затем этот код
```

Также finally выполнится при `throw...` в `catch`