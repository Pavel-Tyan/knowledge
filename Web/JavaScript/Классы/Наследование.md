```JS
class Animal {
  constructor(name) {
    this.speed = 0;
    this.name = name;
  }

  run(speed) {
    this.speed = speed;
    alert(`${this.name} бежит со скоростью ${this.speed}.`);
  }

  stop() {
    this.speed = 0;
    alert(`${this.name} стоит неподвижно.`);
  }
}

let animal = new Animal("Мой питомец");
```

Вот как мы можем представить объект `animal` и класс `Animal` графически:

![[Pasted image 20240910171119.png]]

Синтаксис для расширения другого класса следующий: `class Child extends Parent`.

Давайте создадим `class Rabbit`, который наследуется от `Animal`:
```JS
class Rabbit extends Animal {
  hide() {
    alert(`${this.name} прячется!`);
  }
}

let rabbit = new Rabbit("Белый кролик");

rabbit.run(5); // Белый кролик бежит со скоростью 5.
rabbit.hide(); // Белый кролик прячется!
```

![[Pasted image 20240910171240.png]]

Например, чтобы найти метод `rabbit.run`, движок проверяет (снизу вверх на картинке):

1. Объект `rabbit` (не имеет `run`).
2. Его прототип, то есть `Rabbit.prototype` (имеет `hide`, но не имеет `run`).
3. Его прототип, то есть (вследствие `extends`) `Animal.prototype`, в котором, наконец, есть метод `run`.

__После `extends` разрешены любые выражения
Синтаксис создания класса допускает указывать после `extends` не только класс, но и любое выражение.__

## Переопределение методов
Теперь давайте продвинемся дальше и переопределим метод. По умолчанию все методы, не указанные в классе `Rabbit`, берутся непосредственно «как есть» из класса `Animal`.

Но если мы укажем в `Rabbit` собственный метод, например `stop()`, то он будет использован вместо него

Впрочем, обычно мы не хотим полностью заменить родительский метод, а скорее хотим сделать новый на его основе, изменяя или расширяя его функциональность. Мы делаем что-то в нашем методе и вызываем родительский метод до/после или в процессе.

У классов есть ключевое слово `"super"` для таких случаев.

- `super.method(...)` вызывает родительский метод.
- `super(...)` для вызова родительского конструктора (работает только внутри нашего конструктора).

Пусть наш кролик автоматически прячется при остановке:
```JS
class Animal {
  constructor(name) {
    this.speed = 0;
    this.name = name;
  }

  run(speed) {
    this.speed = speed;
    alert(`${this.name} бежит со скоростью ${this.speed}.`);
  }

  stop() {
    this.speed = 0;
    alert(`${this.name} стоит.`);
  }
}

class Rabbit extends Animal {
  hide() {
    alert(`${this.name} прячется!`);
  }

  stop() {
    super.stop(); // вызываем родительский метод stop
    this.hide(); // и затем hide
  }
}

let rabbit = new Rabbit("Белый кролик");
rabbit.run(5); // Белый кролик бежит со скоростью 5.
rabbit.stop(); // Белый кролик стоит. Белый кролик прячется!
```

## У стрелочных функций нет `super`
При обращении к `super` стрелочной функции он берётся из внешней функции.

## Переопределение конструктора
Конструкторы в наследуемых классах должны обязательно вызывать `super(...)`, и (!) делать это перед использованием `this`.

Родительский конструктор всегда использует родительское поле. Переопределение не работает