По спецификации, в качестве ключей для свойств объекта могут использоваться только строки или символы. Ни числа, ни логические значения не подходят.

«Символ» представляет собой уникальный идентификатор.

Создаются новые символы с помощью функции `Symbol()`:
```JS
// Создаем новый символ - id
let id = Symbol();
```

```JS
// Создаем новый символ - id с именем (описанием) 'id'
let id = Symbol('id');
```
Символы гарантированно уникальны. Даже если мы создадим множество символов с одинаковым описанием, это всё равно будут разные символы. Описание – это просто метка, которая ни на что не влияет.

Например, вот два символа с одинаковым описанием – но они не равны:
```JS
let id1 = Symbol('id');
let id2 = Symbol('id');

alert(id1 == id2); // false
```
__Символы не преобразуются автоматически в строки__ 
```JS
let id = Symbol('id');
alert(id) // ошибка TypeError: Cannot convert a Symbol value to a string
```
Это – языковая «защита» от путаницы, ведь строки и символы – принципиально разные типы данных и не должны неконтролируемо преобразовываться друг в друга.

Если же мы действительно хотим вывести символ с помощью `alert`, то необходимо явно преобразовать его с помощью метода `.toString()`
```JS
let id = Symbol('id');
alert(id.toString()); // Это будет работать
```
Или мы можем обратиться к свойству `symbol.description`, чтобы вывести только описание:
```JS
let id = Symbol('id');
alert(id.description); // Это будет работать
```
## Зачем нужны символы

Символы позволяют создавать «скрытые» свойства объектов, к которым нельзя нечаянно обратиться и перезаписать их из других частей программы.

Например, мы работаем с объектами `user`, которые принадлежат стороннему коду. Мы хотим добавить к ним идентификаторы.
```JS
let user = {
	name: 'Вася';
};

let id = Symbol('id');

user[id] = 1;

alert(user[id]); 
```
Почему же лучше использовать `Symbol("id")`, а не строку `"id"`?

Так как объект `user` принадлежит стороннему коду, и этот код также работает с ним, то нам не следует добавлять к нему какие-либо поля. Это небезопасно. Но к символу сложно нечаянно обратиться, сторонний код вряд ли его вообще увидит, и, скорее всего, добавление поля к объекту не вызовет никаких проблем.

Кроме того, предположим, что другой скрипт для каких-то своих целей хочет записать собственный идентификатор в объект `user`. Этот скрипт может быть какой-то JavaScript-библиотекой, абсолютно не связанной с нашим скриптом.

Сторонний код может создать для этого свой символ `Symbol("id")`:
```JS
let id = Symbol('id');
user[id] = 'Их идентификатор' // конфликта не будет, т.к. символы уникальны
```
## Символы в литеральном объекте

Если мы хотим использовать символ при литеральном объявлении объекта `{...}`, его необходимо заключить в квадратные скобки.

Вот так:
```JS
let id = Symbol('id');

let user = {
	name: 'Вася',
	[id]: 123, // Просто 'id: 123' не сработает 
}
```
Это вызвано тем, что нам нужно использовать значение переменной `id` в качестве ключа, а не строку «id».

## Символы игнорируются циклом for in
Свойства, чьи ключи – символы, не перебираются циклом `for..in`.

Это – часть общего принципа «сокрытия символьных свойств». Если другая библиотека или скрипт будут работать с нашим объектом, то при переборе они не получат ненароком наше символьное свойство. `Object.keys(user)` также игнорирует символы.

А вот Object.assign, в отличие от цикла `for..in`, копирует и строковые, и символьные свойства:
## Глобальные символы
Итак, как мы видели, обычно все символы уникальны, даже если их имена совпадают. Но иногда мы наоборот хотим, чтобы символы с одинаковыми именами были одной сущностью. Например, разные части нашего приложения хотят получить доступ к символу `"id"`, подразумевая именно одно и то же свойство.

Для этого существует _глобальный реестр символов_. Мы можем создавать в нём символы и обращаться к ним позже, и при каждом обращении нам гарантированно будет возвращаться один и тот же символ.

Для чтения (или, при отсутствии, создания) символа из реестра используется вызов `Symbol.for(key)`.

Он проверяет глобальный реестр и, при наличии в нём символа с именем `key`, возвращает его, иначе же создаётся новый символ `Symbol(key)` и записывается в реестр под ключом `key`.

```JS
let id = Symbol.for('id');
let idAgain = Symbol.for('id');

alert(id === idAgain) // true;
```

Технически символы скрыты не на 100%. Существует встроенный метод [Object.getOwnPropertySymbols(obj)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols) – с его помощью можно получить все свойства объекта с ключами-символами. Также существует метод [Reflect.ownKeys(obj)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys), который возвращает _все_ ключи объекта, включая символьные.