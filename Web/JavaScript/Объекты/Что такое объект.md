Объекты используются для хранения коллекций различных значений и более сложных сущностей.

Объект может быть создан с помощью фигурных скобок `{…}` с необязательным списком _свойств_. Свойство – это пара «ключ: значение», где `ключ` – это строка (также называемая «именем свойства»), а `значение` может быть чем угодно.
## Создание объекта
```JS
let user = new Object(); // Синтаксис через конструктор
let user = {} // Синтаксис "литерал объекта"
```
## Свойства
```JS
let user = {
	name: 'John', // под ключом "name" хранится значение 'John'
	age: 20
}
```

```JS
// Получаем свойства объекта
alert(user.name); // John
alert(user.age) // 20

// Динамически добавляем новое свойство
user.isAdmin = true;

// Удаление свойства
delete user.age;

let user = {
	name: 'John',
	age: 20,
	'likes birds': true; // Имя свойства может содержать пробел,
	// но тогда нужно использовать кавычки для записи
}

// Обращение к таким свойствам можно записывать так
user['likes birds'] = false;
```
## const
Объект, объявленный как константа, может быть изменён, т.к. объект ссылочный тип и нельзя менять только ссылку на объект, при этом сам объект можно изменить
```JS
const user = {
	name: 'John';
};

user.name = 'Pete'; // Этот код будет работать
```
## Вычисляемые свойства
Мы можем использовать квадратные скобки в литеральной нотации для создания _вычисляемого свойства_.
```JS
let fruit = prompt('Какой фрукт купить?', 'apple');

let bag = {
	// Обернем ключ в квадратные скобки
	['that ' + fruit]: 5 // Имя свойства будет вычислено
}

alert(bag.['that apple']); // 5, если выбрали "apple"
```
## Свойства из переменной
```JS
function makeUser(name, age) {
	return {
		name, // то же самое, что и name: name;
		age, // то же самое, что и age: age;
	} 
}
```
## Ограничения на имена свойств
```JS
let obj = {
	for: 1,
	let: 2, 
	return: 3
};

alert(obj.for + obj.let + obj.return); // 6
```

Нет никаких ограничений к именам свойств. __Они могут быть в виде строк или символов__ (специальный тип для идентификаторов).

Все другие типы данных будут автоматически преобразованы к строке.

Например, если использовать число `0` в качестве ключа, то оно превратится в строку `"0"`:

```JS
let obj = {
	0: 'Тест',
}

alert(obj['0']); // Тест
alert(obj[0]) // Тест, то же свойство
```
## Проверка существования свойства
При обращении к свойству, которого нет, возвращается `undefined` (в строгом режиме будет ошибка). Это позволяет просто проверить существование свойства. Даже если свойства не существует – ошибки не будет!
```JS
let user = {};

alert(user.random === undefined) // true означает, что такого свойства нет
```
Также существует специальный оператор `"in"` для проверки существования свойства в объекте.

Синтаксис оператора:
```JS
'key' in object
```
Пример:
```JS
let user = { name: 'John', age: 30 };

alert('age' in user); // true
alert('random' in user); // false
```
Зачем нужен этот оператор? Для того случая, когда в объекте есть свойство, но его значение `undefined`
```JS
let obj = {
	test: undefined
};

alert(obj.test); // undefined, нельзя сделать правильный вывод
alert('test' in obj);// true, свойство существует, но оно равно undefined
```
Подобные ситуации случаются очень редко, так как `undefined` обычно явно не присваивается. Для «неизвестных» или «пустых» свойств мы используем значение `null`.

[[Symbol]]