Функцию, которая является свойством объекта, называют _методом_ этого объекта.

```JS
let user = {
	age: 30;
};

user.sayHi = function() { // Function Expression
	alert('Привет!');
}

user.sayHi();
```

## Сокращенная запись

```JS
// 2 эквивалентные записи

let user = {
	sayHi: function() { 
		alert('Привет!');
	}
};

let user = {
	sayHi() { 
		alert('Привет!');
	}
};
```

## this
**Для доступа к информации внутри объекта метод может использовать ключевое слово `this`.**  Значение `this` – это объект «перед точкой», который используется для вызова метода.
```JS
let user = {
	age: 30,
	sayHi() { 
		alert(this.age);
	}
};

user.sayHi(); // 30
```
Технически также возможно получить доступ к объекту без ключевого слова `this`, обратившись к нему через внешнюю переменную. …Но такой код ненадёжен, т.к. можно поменять ссылку у этой внешней переменной на другой объект.
## this не является фиксированным
В JavaScript ключевое слово «this» ведёт себя иначе, чем в большинстве других языков программирования. Его можно использовать в любой функции, даже если это не метод объекта.
```JS
function sayHi() { // рабочий код
	alert(this.name);
}
```
Значение `this` вычисляется во время выполнения кода, в зависимости от контекста.
```JS
let user = { name: 'John' };
let admin = { name: 'Admin' };

function sayHi() {
	alert(this.name);
}

user.f = sayHi;
admin.f = sayHi;

user.f() // John, this вычислился во время вызова
admin.f() // Admin, this вычислился во время вызова

// Запись через квадратные скобки
admin['f'](); // Admin
```
## Вызов без объекта
```JS
function sayHi() {
	alert(this);
}

sayHi(); // undefined
```
В строгом режиме (`"use strict"`) в таком коде значением `this` будет являться `undefined`. Если мы попытаемся получить доступ к `this.name` – это вызовет ошибку.

В нестрогом режиме значением `this` в таком случае будет _глобальный объект_ (`window` в браузерe). Это – исторически сложившееся поведение `this`, которое исправляется использованием строгого режима (`"use strict"`).
## У стрелочных функций нет this
Стрелочные функции особенные: у них нет своего «собственного» `this`. Если мы ссылаемся на `this` внутри такой функции, то оно берётся из внешней «нормальной» функции.

Например, здесь `arrow()` использует значение `this` из внешнего метода `user.sayHi()`:
```JS
let user = {
	firstName: 'Ilya',
	sayHi() {
		let arrow = () => alert(this.firstName);
		arrow();
	}
};

user.sayHi(); // Ilya, берем this из sayHi, который равен user.
```