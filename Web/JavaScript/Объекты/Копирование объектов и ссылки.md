Одно из фундаментальных отличий объектов от примитивов заключается в том, что объекты хранятся и копируются «по ссылке»
```JS
// 2 независимые переменные
let message = 'Привет!';
let phrase = message;
```
![[Pasted image 20240907101327.png]]

**Переменная, которой присвоен объект, хранит не сам объект, а его «адрес в памяти» – другими словами, «ссылку» на него.**

```JS
let user = {
	name: 'John';
};
```
![[Pasted image 20240907101422.png]]
```JS
let user = {
	name: 'John';
};

let admin = user; // копируется ссылка
```
![[Pasted image 20240907101502.png]]
## Сравнение по ссылке
Два объекта равны только в том случае, если это один и тот же объект.

```JS
let a = {}
let b = a;

alert(a == b); // true
alert(a === b); // true, т.к. 2 переменные ссылаются на один и тот же объект
```

```JS
let a = {};
let b = {}; // 2 независимых объекта

alert(a == b); // false
```

## Клонирование, объединение, Object.assign
Чтобы сделать дубликат объекта, можно пройтись по его свойствам через `for...in` и скопировать их в новый объект (Если только сами свойства не являются объектами, т.к. их тоже нужно копировать)

Также мы можем использовать для этого метод Object.assign (Также не будет работать со свойствами объектами):
```JS
Object.assign(dest, [src1, src2, src3...])
```
- Первый аргумент `dest` — целевой объект.
- Остальные аргументы `src1, ..., srcN` (может быть столько, сколько необходимо) являются исходными объектами
- Метод копирует свойства всех исходных объектов `src1, ..., srcN` в целевой объект `dest`. Другими словами, свойства всех аргументов, начиная со второго, копируются в первый объект.
- Возвращает объект `dest`.

__Лучше использовать этот способ, т.к. `for..in` не проходит по символьным свойствам.__

## JSON
 _JSON.parse(JSON.stringify(object)) — простой способ, но не подходит для объектов с методами или undefined._
## Вложенное клонирование
Для глубокого клонирования можно использовать функцию `_.cloneDeep(obj)` из библиотеки Lodash или любой другой библиотеки.

[[Symbol]]