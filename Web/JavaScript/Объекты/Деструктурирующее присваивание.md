_Деструктурирующее присваивание_ – это специальный синтаксис, который позволяет нам «распаковать» массивы или объекты в несколько переменных, так как иногда они более удобны.

## Деструктуризация массива

```JS
let arr = ['Ilya', 'Kantor'];

// Деструктурирующее присваивание
// записывает firstName = arr[0];
// surname = arr[1]
// И так далее...
let [firstName, surname] = arr;
alert(firstName); // Ilya
alert(surname); // Kantor
```
Отлично смотрится в сочетании со `split` или другими методами, возвращающими массив:
```JS
let [firstName, surname] = 'Ilya Kantor'.split(' ');
alert(firstName); // Ilya
alert(surname); // Kantor
```

__«Деструктурирующее присваивание» не уничтожает массив. Оно вообще ничего не делает с правой частью присваивания, его задача – только скопировать нужные значения в переменные.__

Это просто короткий вариант записи: 
```JS
let firstName = arr[0];
let surname = arr[1];
```

__Пропускайте элементы, используя запятые__

Нежелательные элементы массива также могут быть отброшены с помощью дополнительной запятой:

```JS
// Пропускаем второй элемент
let [firstName, , title] = ['Julius', 'Caesar', 'Consul']

alert(title) // Consul
```

__Работает с любым перебираемым объектом__

### Цикл с `entries`
```JS
let user = {
	name: 'John',
	age: 30,
};

for (let [key, value] of Object.entries(user)) {
	alert(`${key}:${value}`)
}
// Тоже самое можно сделать для map
```
### Трюк с обменном переменных
```JS
let a = 1;
let b = 2;
// Меняем значения местами
[a, b] = [b, a];
```
### Остаточные параметры
Если мы хотим не просто получить первые значения, но и собрать все остальные, то мы можем добавить ещё один параметр, который получает остальные значения, используя оператор «остаточные параметры» – троеточие (`"..."`):

```JS
let [one, two, ...rest] = [1, 2, 3, 4, 5];

// Собрали оставшуюся часть элементов в отдельный массив rest
alert(rest[0]) // 3
alert(rest[1]) // 4
alert(rest[2]) // 5
alert(rest.length) // 3
```

## Значение по умолчанию
Если в массиве меньше значений, чем в присваивании, то ошибки не будет. Отсутствующие значения считаются неопределёнными:
```JS
let [a, b] = []
alert(a) // undefined
alert(b) // undefined
```
Если мы хотим, чтобы значение «по умолчанию» заменило отсутствующее, мы можем указать его с помощью `=`:
```JS
let [a = 1, b = 2] = []
alert(a) // 1
alert(b) // 2
```
__Значения по умолчанию могут быть гораздо более сложными выражениями или даже функциями. Они выполняются, только если значения отсутствуют.__

## Деструктуризация объекта

```JS
let { var1, var2 } = { var1: ..., var2: ...}
```

У нас есть существующий объект с правой стороны, который мы хотим разделить на переменные. Левая сторона содержит «шаблон» для соответствующих свойств. В простом случае это список названий переменных в `{...}`.

```JS
let user = {
	age: 30,
	name: 'Ilya'
}

let { age, name } = options
alert(age) // 30
alert(name) // Ilya
```

Свойства `user.age`, `user.name` присваиваются соответствующим переменным.

Порядок не имеет значения. Вот так – тоже работает:

```JS
let { name, age } = options
```

Шаблон с левой стороны может быть более сложным и определять соответствие между свойствами и переменными.

Если мы хотим присвоить свойство объекта переменной с другим названием, например, свойство `user.age` присвоить переменной `a`, то мы можем использовать двоеточие:

```JS
let user = {
	age: 30,
	name: 'Ilya'
}

let { age: a, name: n } = options;

alert(a) // 30
alert(n) // Ilya
```

```JS
let age, name;
// Это не будет работать
// JS будет воспринимать это как блок кода
{ age, name } = options

// Это будет работать
({age, name} = option)
```